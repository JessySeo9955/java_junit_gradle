/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java library project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.14/userguide/building_java_projects.html in the Gradle documentation.
 */
import org.gradle.api.tasks.testing.TestDescriptor
import org.gradle.api.tasks.testing.TestResult

plugins {
	// Apply the java-library plugin for API and implementation separation.
	`java-library`  // adds 'test' task
	`eclipse`
	`application`
}

application {
	// Specify the main class to run (entry point)
	 mainClass.set("junit.gradle.HelloWorld")
}

repositories {
	// Use Maven Central for resolving dependencies.
	mavenCentral()
}

dependencies {
	////////////////////////////////////////// TESTING for JUNIT ////////////////////////////////////////////////////////////////////////
	// Used to write and run unit tests in src/test/java.
	//testImplementation(libs.junit.jupiter)
	testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.0")
	testImplementation("org.junit.jupiter:junit-jupiter-engine:5.10.0")

	testImplementation("org.junit.jupiter:junit-jupiter-params:5.10.0") // âœ… Needed for @ParameterizedTest
	// Mockito core for mocking
	testImplementation("org.mockito:mockito-core:5.17.0")

	// Mockito JUnit 5 extension to use Mockito with JUnit 5
	testImplementation("org.mockito:mockito-junit-jupiter:5.17.0")

	// Enables Gradle (and IDEs) to discover and run JUnit 5 tests properly.
	testRuntimeOnly("org.junit.platform:junit-platform-launcher")

	// AssertJ for fluent assertions
	testImplementation("org.assertj:assertj-core:3.25.1")

	////////////////////////////////////////// TESTING for CUCUMBER ////////////////////////////////////////////////////////////////////////
	// Cucumber JVM with JUnit 5 support
	testImplementation("io.cucumber:cucumber-java:7.22.2")
	testImplementation("io.cucumber:cucumber-junit:7.22.2")
	testImplementation("io.cucumber:cucumber-junit-platform-engine:7.22.2")
	testImplementation("org.junit.platform:junit-platform-suite:1.12.2")

	/////////////////////////////////////// AWS LAMBDA //////////////////////////////////////////////////////////////////////////////////////////
   implementation("com.amazonaws:aws-lambda-java-core:1.2.2")
    implementation("com.amazonaws:aws-lambda-java-events:3.11.1")
	implementation("com.amazonaws:aws-lambda-java-events:3.11.0")
    runtimeOnly("com.amazonaws:aws-lambda-java-log4j2:1.5.1")
 

	// This dependency is part of your public API.
	// This dependency is exported to consumers, that is to say found on their compile classpath.
	// Apache Commons Math: A math library offering functions for statistics, geometry, linear algebra, etc.
	api(libs.commons.math3)

	// This is used by your code, but not exposed to users of your library/module.
	// This dependency is used internally, and not exposed to consumers on their own compile classpath.
	// Google Guava: A utility library offering advanced collections, caching, functional programming, etc.

	implementation("com.fasterxml.jackson.core:jackson-databind:2.15.0")
	
	

}

// Apply a specific Java toolchain to ease working on different environments.
java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
}


// All libraries  included - simple, easy way
tasks.register<Jar>("fatJar") {
    group = "build"
    description = "Builds a self-contained JAR for AWS Lambda"

    archiveBaseName.set("app")
    archiveVersion.set("")
    archiveClassifier.set("")

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    manifest {
        attributes["Main-Class"] = "junit.gradle.HelloWorld"
    }

    from(sourceSets.main.get().output)

    dependsOn(configurations.runtimeClasspath)
    from({
        configurations.runtimeClasspath.get().filter { it.name.endsWith("jar") }.map { zipTree(it) }
    })
}

//seperate lib files -  If I need to use lambda layer
tasks.register<Zip>("buildLambdaZip") {
    group = "build"
    description = "Package AWS Lambda zip with JAR and dependencies"

    dependsOn("fatJar") // Ensure fatJar is created before this task runs

    destinationDirectory.set(layout.buildDirectory.dir("distributions"))
    archiveFileName.set("lambda.zip")

    // Put the fat JAR inside the zip
    into("lib") {
        from(tasks.named<Jar>("fatJar").flatMap { it.archiveFile })
    }
}

// Runs first and ensures that fatJar runs as part of the build process.
tasks.named("build") {
    dependsOn("fatJar")
}

// Creates the fat JAR that includes all your dependencies.
tasks.named("startScripts") {
    dependsOn("fatJar")
}


tasks.named<Test>("test") {
	// Use JUnit Platform for unit tests.
	useJUnitPlatform()


	// show standard out and standard error of the test JVM(s) on the console
	testLogging {
		events("passed", "skipped", "failed") // Specifies which test events to log
		showStandardStreams =
			true // Show standard output (System.out.println) and standard error (System.err) during test execution

	}

	jvmArgs = listOf(
		"-javaagent:${configurations.testRuntimeClasspath.get().find { it.name.contains("mockito-core") }}=inline"
	)

	systemProperty("cucumber.junit-platform.naming-strategy", "long")

}


